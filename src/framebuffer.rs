use crate::cpu57_core::{CPU57, Opcode, REGISTER_COUNT};
use core::ptr;

pub const VGA_WIDTH: usize = 640;
pub const VGA_HEIGHT: usize = 480;
pub const VGA_BUFFER: *mut u8 = 0xA0000 as *mut u8;

#[repr(C)]
#[derive(Clone, Copy)]
pub struct Color {
    pub b: u8,
    pub g: u8,
    pub r: u8,
}

impl Color {
    pub const fn new(r: u8, g: u8, b: u8) -> Self {
        Color { r, g, b }
    }
    
    pub const BLACK: Color = Color::new(0, 0, 0);
    pub const WHITE: Color = Color::new(255, 255, 255);
    pub const RED: Color = Color::new(220, 40, 40);
    pub const GREEN: Color = Color::new(40, 220, 40);
    pub const BLUE: Color = Color::new(40, 100, 220);
    pub const YELLOW: Color = Color::new(220, 220, 40);
    pub const CYAN: Color = Color::new(40, 220, 220);
    pub const MAGENTA: Color = Color::new(220, 40, 220);
    pub const GRAY: Color = Color::new(128, 128, 128);
    pub const DARK_GRAY: Color = Color::new(64, 64, 64);
    pub const ORANGE: Color = Color::new(255, 140, 0);
}

pub struct Framebuffer {
    buffer: *mut u8,
    width: usize,
    height: usize,
    bpp: usize,
}

impl Framebuffer {
    pub fn new(buffer: *mut u8, width: usize, height: usize, bpp: usize) -> Self {
        Framebuffer {
            buffer,
            width,
            height,
            bpp,
        }
    }
    
    pub fn put_pixel(&mut self, x: usize, y: usize, color: Color) {
        if x >= self.width || y >= self.height {
            return;
        }
        
        let offset = (y * self.width + x) * (self.bpp / 8);
        unsafe {
            ptr::write_volatile(self.buffer.add(offset), color.b);
            ptr::write_volatile(self.buffer.add(offset + 1), color.g);
            ptr::write_volatile(self.buffer.add(offset + 2), color.r);
        }
    }
    
    pub fn fill_rect(&mut self, x: usize, y: usize, w: usize, h: usize, color: Color) {
        for dy in 0..h {
            for dx in 0..w {
                self.put_pixel(x + dx, y + dy, color);
            }
        }
    }
    
    pub fn draw_line(&mut self, x0: usize, y0: usize, x1: usize, y1: usize, color: Color) {
        let dx = (x1 as i32 - x0 as i32).abs();
        let dy = -(y1 as i32 - y0 as i32).abs();
        let sx = if x0 < x1 { 1 } else { -1 };
        let sy = if y0 < y1 { 1 } else { -1 };
        let mut err = dx + dy;
        
        let mut x = x0 as i32;
        let mut y = y0 as i32;
        
        loop {
            self.put_pixel(x as usize, y as usize, color);
            
            if x == x1 as i32 && y == y1 as i32 {
                break;
            }
            
            let e2 = 2 * err;
            if e2 >= dy {
                err += dy;
                x += sx;
            }
            if e2 <= dx {
                err += dx;
                y += sy;
            }
        }
    }
    
    pub fn draw_char(&mut self, x: usize, y: usize, c: char, color: Color) {
        let font = FONT_8X8;
        let glyph = if (c as usize) < 128 {
            font[c as usize]
        } else {
            font[0]
        };
        
        for row in 0..8 {
            for col in 0..8 {
                if (glyph[row] & (1 << (7 - col))) != 0 {
                    self.put_pixel(x + col, y + row, color);
                }
            }
        }
    }
    
    pub fn draw_string(&mut self, x: usize, y: usize, s: &str, color: Color) {
        let mut offset = 0;
        for c in s.chars() {
            self.draw_char(x + offset * 8, y, c, color);
            offset += 1;
        }
    }
    
    pub fn draw_hex(&mut self, x: usize, y: usize, value: u64, width: usize, color: Color) {
        let hex_chars = b"0123456789ABCDEF";
        for i in 0..width {
            let nibble = ((value >> ((width - 1 - i) * 4)) & 0xF) as usize;
            self.draw_char(x + i * 8, y, hex_chars[nibble] as char, color);
        }
    }
    
    pub fn clear(&mut self, color: Color) {
        self.fill_rect(0, 0, self.width, self.height, color);
    }
}

pub struct CPUUI {
    fb: Framebuffer,
    bus_history: [u64; 32],
    bus_index: usize,
}

impl CPUUI {
    pub fn new(fb: Framebuffer) -> Self {
        CPUUI {
            fb,
            bus_history: [0; 32],
            bus_index: 0,
        }
    }
    
    pub fn render(&mut self, cpu: &CPU57) {
        self.fb.clear(Color::BLACK);
        
        self.draw_nav_bar();
        self.draw_registers(cpu);
        self.draw_instruction(cpu);
        self.draw_flags(cpu);
        self.draw_bus_activity(cpu);
        self.draw_memory_view(cpu);
        self.draw_stats(cpu);
    }
    
    fn draw_nav_bar(&mut self) {
        self.fb.fill_rect(0, 0, VGA_WIDTH, 30, Color::DARK_GRAY);
        self.fb.draw_string(10, 10, "CPU-57 Monitor", Color::CYAN);
        self.fb.draw_string(200, 10, "Cycle:", Color::WHITE);
        self.fb.draw_string(480, 10, "Status:", Color::WHITE);
    }
    
    fn draw_registers(&mut self, cpu: &CPU57) {
        let base_x = 10;
        let base_y = 50;
        
        self.fb.draw_string(base_x, base_y, "REGISTERS", Color::YELLOW);
        
        for i in 0..REGISTER_COUNT {
            let x = base_x + (i % 4) * 150;
            let y = base_y + 20 + (i / 4) * 12;
            
            // format register name without format! macro
            let mut reg_name = [0u8; 4];
            reg_name[0] = b'R';
            if i < 10 {
                reg_name[1] = b'0';
                reg_name[2] = b'0' + i as u8;
                reg_name[3] = 0;
            } else {
                reg_name[1] = b'0' + (i / 10) as u8;
                reg_name[2] = b'0' + (i % 10) as u8;
                reg_name[3] = 0;
            }
            
            // convert to str (safe because it's ASCII... i guess)
            let reg_str = core::str::from_utf8(&reg_name[..3]).unwrap_or("R??");
            
            self.fb.draw_string(x, y, reg_str, Color::GREEN);
            self.fb.draw_string(x + 32, y, ":", Color::WHITE);
            self.fb.draw_hex(x + 40, y, cpu.registers[i].get(), 14, Color::CYAN);
        }
        
        let pc_y = base_y + 20 + ((REGISTER_COUNT / 4) + 1) * 12;
        self.fb.draw_string(base_x, pc_y, "PC:", Color::ORANGE);
        self.fb.draw_hex(base_x + 32, pc_y, cpu.pc.get(), 14, Color::CYAN);
        
        self.fb.draw_string(base_x + 200, pc_y, "SP:", Color::ORANGE);
        self.fb.draw_hex(base_x + 232, pc_y, cpu.sp.get(), 14, Color::CYAN);
    }
    
    fn draw_instruction(&mut self, cpu: &CPU57) {
        let base_x = 10;
        let base_y = 280;
        
        self.fb.draw_string(base_x, base_y, "CURRENT INSTRUCTION", Color::YELLOW);
        
        if let Some(inst) = cpu.current_instruction {
            let opcode_name = self.opcode_name(inst.opcode);
            self.fb.draw_string(base_x, base_y + 20, "Opcode:", Color::GREEN);
            self.fb.draw_string(base_x + 64, base_y + 20, opcode_name, Color::MAGENTA);
            
            self.fb.draw_string(base_x, base_y + 35, "RD:", Color::GREEN);
            self.fb.draw_hex(base_x + 32, base_y + 35, inst.rd as u64, 2, Color::CYAN);
            
            self.fb.draw_string(base_x + 80, base_y + 35, "RS1:", Color::GREEN);
            self.fb.draw_hex(base_x + 120, base_y + 35, inst.rs1 as u64, 2, Color::CYAN);
            
            self.fb.draw_string(base_x + 160, base_y + 35, "RS2:", Color::GREEN);
            self.fb.draw_hex(base_x + 200, base_y + 35, inst.rs2 as u64, 2, Color::CYAN);
            
            self.fb.draw_string(base_x, base_y + 50, "IMM:", Color::GREEN);
            self.fb.draw_hex(base_x + 40, base_y + 50, inst.immediate.get(), 14, Color::CYAN);
        } else {
            self.fb.draw_string(base_x, base_y + 20, "No instruction", Color::GRAY);
        }
    }
    
    fn draw_flags(&mut self, cpu: &CPU57) {
        let base_x = 350;
        let base_y = 280;
        
        self.fb.draw_string(base_x, base_y, "FLAGS", Color::YELLOW);
        
        let z_color = if cpu.flags.zero { Color::GREEN } else { Color::GRAY };
        let c_color = if cpu.flags.carry { Color::GREEN } else { Color::GRAY };
        let o_color = if cpu.flags.overflow { Color::GREEN } else { Color::GRAY };
        let n_color = if cpu.flags.negative { Color::GREEN } else { Color::GRAY };
        
        self.fb.draw_string(base_x, base_y + 20, "Z", z_color);
        self.fb.draw_string(base_x + 20, base_y + 20, "C", c_color);
        self.fb.draw_string(base_x + 40, base_y + 20, "O", o_color);
        self.fb.draw_string(base_x + 60, base_y + 20, "N", n_color);
    }
    
    fn draw_bus_activity(&mut self, cpu: &CPU57) {
        let base_x = 10;
        let base_y = 360;
        
        self.fb.draw_string(base_x, base_y, "BUS ACTIVITY", Color::YELLOW);
        
        if cpu.bus_active {
            self.bus_history[self.bus_index] = cpu.data_bus.get();
            self.bus_index = (self.bus_index + 1) % self.bus_history.len();
        }
        
        self.fb.draw_string(base_x, base_y + 20, "ADDR:", Color::GREEN);
        self.fb.draw_hex(base_x + 48, base_y + 20, cpu.address_bus.get(), 14, Color::ORANGE);
        
        self.fb.draw_string(base_x, base_y + 35, "DATA:", Color::GREEN);
        self.fb.draw_hex(base_x + 48, base_y + 35, cpu.data_bus.get(), 14, Color::ORANGE);
        
        let graph_y = base_y + 55;
        let graph_height = 40;
        
        for i in 0..self.bus_history.len() {
            let idx = (self.bus_index + i) % self.bus_history.len();
            let value = self.bus_history[idx];
            let normalized = ((value & 0xFFFF) as f32 / 65535.0 * graph_height as f32) as usize;
            
            let x = base_x + i * 8;
            let color = if i == self.bus_history.len() - 1 {
                Color::GREEN
            } else {
                Color::CYAN
            };
            
            if normalized > 0 {
                self.fb.draw_line(x, graph_y + graph_height, x, graph_y + graph_height - normalized, color);
            }
        }
    }
    
    fn draw_memory_view(&mut self, cpu: &CPU57) {
        let base_x = 350;
        let base_y = 360;
        
        self.fb.draw_string(base_x, base_y, "MEMORY", Color::YELLOW);
        
        let addr = cpu.pc.get() as usize;
        for i in 0..8 {
            let mem_addr = (addr + i * 16).min(cpu.memory.len() - 1);
            let y = base_y + 20 + i * 12;
            
            self.fb.draw_hex(base_x, y, mem_addr as u64, 8, Color::GREEN);
            self.fb.draw_string(base_x + 72, y, ":", Color::WHITE);
            
            for j in 0..8 {
                let byte_addr = mem_addr + j;
                if byte_addr < cpu.memory.len() {
                    let byte = cpu.memory[byte_addr];
                    self.fb.draw_hex(base_x + 88 + j * 20, y, byte as u64, 2, Color::CYAN);
                }
            }
        }
    }
    
    fn draw_stats(&mut self, cpu: &CPU57) {
        let cycles = cpu.cycle_count;
        self.fb.draw_hex(250, 10, cycles, 12, Color::GREEN);
        
        let status = if cpu.halted { "HALTED" } else { "RUNNING" };
        let status_color = if cpu.halted { Color::RED } else { Color::GREEN };
        self.fb.draw_string(540, 10, status, status_color);
    }
    
    fn opcode_name(&self, opcode: Opcode) -> &'static str {
        match opcode {
            Opcode::NOP => "NOP",
            Opcode::ADD => "ADD",
            Opcode::SUB => "SUB",
            Opcode::MUL => "MUL",
            Opcode::DIV => "DIV",
            Opcode::AND => "AND",
            Opcode::OR => "OR",
            Opcode::XOR => "XOR",
            Opcode::NOT => "NOT",
            Opcode::SHL => "SHL",
            Opcode::SHR => "SHR",
            Opcode::ROL => "ROL",
            Opcode::ROR => "ROR",
            Opcode::LOAD => "LOAD",
            Opcode::STORE => "STORE",
            Opcode::LOADI => "LOADI",
            Opcode::MOV => "MOV",
            Opcode::CMP => "CMP",
            Opcode::JMP => "JMP",
            Opcode::JZ => "JZ",
            Opcode::JNZ => "JNZ",
            Opcode::JC => "JC",
            Opcode::JNC => "JNC",
            Opcode::CALL => "CALL",
            Opcode::RET => "RET",
            Opcode::PUSH => "PUSH",
            Opcode::POP => "POP",
            Opcode::IN => "IN",
            Opcode::OUT => "OUT",
            Opcode::HLT => "HLT",
        }
    }
}

const FONT_8X8: [[u8; 8]; 128] = [
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E],
    [0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E],
    [0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00],
    [0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00],
    [0x38, 0x7C, 0x38, 0xFE, 0xFE, 0x7C, 0x38, 0x7C],
    [0x10, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x7C],
    [0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00],
    [0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF],
    [0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00],
    [0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF],
    [0x0F, 0x07, 0x0F, 0x7D, 0xCC, 0xCC, 0xCC, 0x78],
    [0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18],
    [0x3F, 0x33, 0x3F, 0x30, 0x30, 0x70, 0xF0, 0xE0],
    [0x7F, 0x63, 0x7F, 0x63, 0x63, 0x67, 0xE6, 0xC0],
    [0x99, 0x5A, 0x3C, 0xE7, 0xE7, 0x3C, 0x5A, 0x99],
    [0x80, 0xE0, 0xF8, 0xFE, 0xF8, 0xE0, 0x80, 0x00],
    [0x02, 0x0E, 0x3E, 0xFE, 0x3E, 0x0E, 0x02, 0x00],
    [0x18, 0x3C, 0x7E, 0x18, 0x18, 0x7E, 0x3C, 0x18],
    [0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00],
    [0x7F, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x00],
    [0x3E, 0x63, 0x38, 0x6C, 0x6C, 0x38, 0xCC, 0x78],
    [0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x00],
    [0x18, 0x3C, 0x7E, 0x18, 0x7E, 0x3C, 0x18, 0xFF],
    [0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00],
    [0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00],
    [0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00],
    [0x00, 0x30, 0x60, 0xFE, 0x60, 0x30, 0x00, 0x00],
    [0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00],
    [0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00],
    [0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x00, 0x00],
    [0x00, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00],
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00],
    [0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00],
    [0x30, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x30, 0x00],
    [0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00],
    [0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00],
    [0x60, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00],
    [0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00],
    [0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00],
    [0x00, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x00, 0x00],
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60],
    [0x00, 0x00, 0x00, 0xFC, 0x00, 0x00, 0x00, 0x00],
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00],
    [0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00],
    [0x7C, 0xC6, 0xCE, 0xDE, 0xF6, 0xE6, 0x7C, 0x00],
    [0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00],
    [0x78, 0xCC, 0x0C, 0x38, 0x60, 0xCC, 0xFC, 0x00],
    [0x78, 0xCC, 0x0C, 0x38, 0x0C, 0xCC, 0x78, 0x00],
    [0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00],
    [0xFC, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00],
    [0x38, 0x60, 0xC0, 0xF8, 0xCC, 0xCC, 0x78, 0x00],
    [0xFC, 0xCC, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00],
    [0x78, 0xCC, 0xCC, 0x78, 0xCC, 0xCC, 0x78, 0x00],
    [0x78, 0xCC, 0xCC, 0x7C, 0x0C, 0x18, 0x70, 0x00],
    [0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x00],
    [0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60],
    [0x18, 0x30, 0x60, 0xC0, 0x60, 0x30, 0x18, 0x00],
    [0x00, 0x00, 0xFC, 0x00, 0x00, 0xFC, 0x00, 0x00],
    [0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00],
    [0x78, 0xCC, 0x0C, 0x18, 0x30, 0x00, 0x30, 0x00],
    [0x7C, 0xC6, 0xDE, 0xDE, 0xDE, 0xC0, 0x78, 0x00],
    [0x30, 0x78, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0x00],
    [0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00],
    [0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00],
    [0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00],
    [0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00],
    [0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00],
    [0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3E, 0x00],
    [0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00],
    [0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00],
    [0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00],
    [0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00],
    [0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00],
    [0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00],
    [0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00],
    [0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00],
    [0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00],
    [0x78, 0xCC, 0xCC, 0xCC, 0xDC, 0x78, 0x1C, 0x00],
    [0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00],
    [0xF0, 0x60, 0x60, 0xF8, 0x6C, 0x66, 0xF3, 0x00],
    [0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00],
    [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00],
    [0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00],
    [0xC6, 0xC6, 0x6C, 0x38, 0x38, 0x6C, 0xC6, 0x00],
    [0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x3C, 0x00],
    [0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00],
    [0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00],
    [0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00],
    [0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00],
    [0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00],
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF],
    [0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00],
    [0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, 0xDC, 0x00],
    [0x00, 0x00, 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x00],
    [0x1C, 0x0C, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00],
    [0x00, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00],
    [0x38, 0x6C, 0x60, 0xF0, 0x60, 0x60, 0xF0, 0x00],
    [0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8],
    [0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00],
    [0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00],
    [0x0C, 0x00, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78],
    [0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00],
    [0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00],
    [0x00, 0x00, 0xCC, 0xFE, 0xFE, 0xD6, 0xC6, 0x00],
    [0x00, 0x00, 0xF8, 0xCC, 0xCC, 0xCC, 0xCC, 0x00],
    [0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00],
    [0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0],
    [0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E],
    [0x00, 0x00, 0xDC, 0x76, 0x66, 0x60, 0xF0, 0x00],
    [0x00, 0x00, 0x7C, 0xC0, 0x78, 0x0C, 0xF8, 0x00],
    [0x10, 0x30, 0x7C, 0x30, 0x30, 0x34, 0x18, 0x00],
    [0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00],
    [0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00],
    [0x00, 0x00, 0xC6, 0xD6, 0xFE, 0xFE, 0x6C, 0x00],
    [0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00],
    [0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8],
    [0x00, 0x00, 0xFC, 0x98, 0x30, 0x64, 0xFC, 0x00],
    [0x1C, 0x30, 0x30, 0xE0, 0x30, 0x30, 0x1C, 0x00],
    [0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00],
    [0xE0, 0x30, 0x30, 0x1C, 0x30, 0x30, 0xE0, 0x00],
    [0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    [0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0x00],
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
];